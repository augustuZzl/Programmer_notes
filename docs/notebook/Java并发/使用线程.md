实现 Runnable 接口； 实现 Callable 接口； 继承 Thread 类。

> 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需 要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

#### 继承 Thread

java.lang.Thread 类代表**线程**，所有的线程对象必须是 Thread 类或其子类的实例，每个线程的作用就是完成一定的任务即执行一段程序流。

下面实现步骤：

- 定义一个类继承 Thread，并重写该类的 run() 方法，该方法的方法体就是线程需要完成的任务，因此把 run 方法称为线程执行体。

  ```java
  public class MyThread extends Thread {
  	@Override
  	public void run() {
  		for(int i = 0; i < 3; i++){
  			System.out.println("MyThread---" + i);
  		}
  	}
  }
  ```

- 创建该类的实例，即创建了线程对象。

- 调用线程对象的 start() 方法启动该线程。

  ```java
  public static void main(String[] args) {
      MyThread myThread = new MyThread();
      myThread.start();
      //myThread.run();
  
      for(int i = 0; i < 3; i++){
          System.out.println("MainThread---" + i);
      }
  }
  ```

运行结果（随机）：

```text
MainThread---0
MyThread---0
MyThread---1
MyThread---2
MainThread---1
MainThread---2
```

程序很好理解，run() 方法中的循环和 mian 方法中的循环占用两个线程，谁得到了 cpu 的青睐谁便会执行，所以出现结果的随机性。那为什么不调用 run方法呢？我们画一个图来理解一下。

![](https://ws1.sinaimg.cn/large/006DgVHEly1g11exq2q7aj30mp0erq3b.jpg)

#### 实现 Runnable

1. 创建类实现 Runnable 接口（Thread 类也实现了 Runnable）
2. 重写 run() 方法，设置线程任务
3. 创建该类的实例
4. 创建 Thread 类实例，构造方法中传入上面那个实现接口的实例
5. 调用 start() 方法

```java
public class MyThread implements Runnable {
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName());
	}
}
public static void main(String[] args) {
    MyThread myThread = new MyThread();
    Thread thread = new Thread(myThread);
    thread.start(); // Thread-0
}
```

#### 实现 Callable

> 与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

1. 创建类实现 Callable 接口
2. 重写 call() 方法，设置线程任务
3. 创建该类的实例
4. 创建 FutureTask 类实例，在构造方法中传入自己类的实例
5. 创建 Thread 类实例，构造函数中传入 FutureTask 实例
6.  调用 start() 方法

```java
public class MyCallable implements Callable<Integer> {    
    public Integer call() {        
        return 123;    
    } 
}
public static void main(String[] args) throws ExecutionException, InterruptedException{ 
    MyCallable mc = new MyCallable();    
    FutureTask<Integer> ft = new FutureTask<>(mc);    
    Thread thread = new Thread(ft);    
    thread.start();    
    System.out.println(ft.get()); 
}
```

