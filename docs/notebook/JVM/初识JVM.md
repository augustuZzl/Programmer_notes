##### 问题1

**简要阐述补码的好处。并计算给出 -99, -105, 205 整数的补码**

关于二进制、补码、反码等知识在 [Java基础/基本的编程结构](notebook/Java基础/基本的编程结构) 里详细的说了。

- 0 的表示

0 既不是正数也不是负数，如果我们要表示他，怎么办呢？这里使用两个字节进行解释

把它看成正数是：00000000，把它看成负数是：10000000，如果我们用补码表示呢？

正数时的补码是：00000000，负数时的补码是：00000000，这样就表示的一样了。

- 运算

我们来计算 -2 + 1 = -1 这个运算

当使用原码时：

-2 ：10000010，1：00000001，他们相加 = 00000011，然而 -1 应表示为 100000001，不相符

当使用补码时：

-2：11111110，1：00000001，他们相加 = 11111111，-1 的补码正好是 11111111。

综上所述，使用补码可以更好表示和运算

##### 问题2 

**计算 1 10000010 00100000000000000000000 的单精度浮点的值，并给出计算过程。**

- s eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm
- e 全为 0 尾数附加位为 0  否则尾数附加位为 1
- s * m * 2 ^ (e - 127)

符号位 s 为 1，所以是负数。e = 10000010，所以尾数为附加 1，所以 m：100100000000000000000000

s = -1，e = 130，m = 1 * 2 ^ 0 + 1 * 2 ^ -3 = 1 + 1/8

result = -1 * 9/8 * 2 ^ 3 = -9

```java
float f = -9;
int i = Float.floatToIntBits(f);
String s = Integer.toBinaryString(i);
System.out.println(s); // 11000001000100000000000000000000
```

##### 问题3

**将100.2转成二进制表示 ，给出程序和结果。**

```java
float f = 100.2f;
int a = (int) f;
for(int i = 0; i < 32; i++){
    int t=(a & 0x80000000>>>i)>>>(31-i);
    System.out.print(t);
}
```

result：00000000000000000000000001100100

0x80000000表示第一位是 1，其余位都是 0，因此把它这 1 分别与 a 的 32 位做与运算，就能逐个输出 a 的每位是 1 还是 0 了，这样就输出了 a 的二进制了。

我们可以用问题二进行验证一下：

正数，s = 1，e = 0，m = 0 00000000000000001100100 = 2 ^ -17 + 2 ^ -18 + 2 ^ -21 = 

result = 1 * (2 ^ -17 + 2 ^ -18 + 2 ^ -21) * 2 ^ -127，发现好像不对啊