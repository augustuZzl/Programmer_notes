### 二叉树

- 和链表一样，动态的数据结构，具有天然的递归结构。即每个节点的左右子树也是二叉树

- 二叉树有唯一的根节点，一个节点也是二叉树，空也是二叉树

- 每个节点最多有两个孩子

- 每个节点最多有一个父亲

```java
class Node{
    E e;
    Node left;	// 左孩子
    Node right; // 右孩子
}
```

### 二分搜索树

- 二分搜索树是二叉树
- 二分搜索树的**每个节点**的值：
  - 大于其左子树的所有节点的值
  - 小于其右子树的所有节点的值
- 因此，存储的元素必须有可比较性

我们来实现一下二分搜索树：

```java
public class BST<E extends Comparable<E>> {
    // 节点子类
    private class Node{
        public E e;
        public Node left,right;
        public Node(E e){
            this.e = e;
            left = null;
            right = null;
        }
    }
   	// 根节点
    private Node root;
    // 元素个数
    private int size;
    // 构造函数，与默认空构造函数效果一样
    public BST(){
        root = null;
        size = 0;
    }
    // 返回元素个数
    public int size(){
        return size;
    }
    // 是否为空
    public boolean isEmpty(){
        return size == 0;
    }
    @Override
    public String toString(){
        
    }
    
}
```

#### 添加元素

添加元素时，只需要根据左小右大进行就可以了，但是如果出现重复元素呢？那么我们就可以定义：左子树小于等于节点；或者右子树大于等于节点。在此假设我们的二分搜索树不包含重复元素。

因为要与左右节点进行比较，我们可以使用递归解决问题

```java
public void add(E e){
    // 如果根节点为 null,那么此元素就成为根节点
    if(root == null){
        root = new Node(e);
        size ++;
    } else{	// 开始递归，开始比较每个元素，插入元素
        add(root, e);
    }
}
private void add(Node node, E e){
    // 如果与节点相等，我们不处理
    if(e.equals(node.e)){
        return;
     // 如果小于节点且其左子树为空，那么就成为左节点 
    }else if(e.compareTo(node.e) <0 && node.left == null){
        node.left = new Node(e);
        size ++;
        return;
     // 如果大于于节点且其右子树为空，那么就成为右节点
    }else if(e.compareTo(node.e) >0 && node.right == null){
        node.right = new Node(e);
        size ++;
        return;
    }
    // 如果小于节点，且其有左子树，那么递归，与其左子树进行比较
    if(e.compareTo(node.e) < 0)
        add(node.left, e);
    else 
        add(node.right, e);
}
```

我们使用递归一步一步完全的实现了插入元素，思路很基础，很容易理解。但是我们发现，从一开始我们就一直判断 null ，那么我们可以怎么优化这个函数呢？

现在我们思考这么一个思路。

- 若父节点为空，那么这个带插入元素就是父节点：那么设置父节点为该元素
- 若父节点不为空，那么比较：
  - 待插入元素小于父节点，那么就以父节点的左节点为父节点进行第一步
  - 待插入元素大于父节点，那么就以父节点的右节点为父节点进行第一步

用代码来实现一下，加深理解：

```java
public void add(E e){
    root = add(root, e);
}
// 传入一个节点，设置好其左右节点后返回该节点。
private Node add(Node node, E e){
    if(node ==null){
        node = new Node(e);
        size ++;
        return node;
    }
    if(e.compareTo(node.left) < 0)
        node.left = add(node.left, e);
    else if(e.compareTO(node.right) > 0){
        node.right = add(node.right, e);
    }
    return node;
}
```

可能有点难以理解，我们可以生成一点数据来模拟一下这个过程。

#### 搜索元素

这个相比较添加元素就比较简单了。

```java
public boolean contains(E e){
    return contains(root, e);
}
private boolean contains(Node node, E e){
    if(node == null){
        return false;
    }
    if(e.compareTo(nodde.e) == 0)
        return true;
    else if(e.compareTo(node.e) <0)
        return contains(node.left, e);
    else if(e.compareTo(node.e) >0)
        return contains(node.right, e)

}
```

#### 遍历元素

##### 前序遍历

先访问该节点，然后访问左、右节点：

```java
public void perOrder(){
    preOrder(root);
}
private void perOrder(Node node){
    if(node == null)
        return;
    System.out.println(node.e);
    preOrder(node.left);
    preOrder(node.right);
    
}
```

##### 中序遍历

先访问左子树，然后该节点，然后右子树

```java
public void inOrder(){
    inOrder(root);
}
private void inOrder(Node node){
    if(node == null)
        return;
    inOrder(node.left);
    System.out.println(node.e);
    inOrder(node.right);
    
}
```

结果：顺序的

##### 后序遍历

先访问左右子树，最后访问该节点

```java
public void postOrder(){
    postOrder(root);
}
private void postOrder(Node node){
    if(node == null)
        return;
    postOrder(node.left);
    postOrder(node.right);
    System.out.println(node.e);
    
}
```

可以用来释放内存