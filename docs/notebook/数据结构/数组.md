# 第一章：数组

## Java 中的数组

### 创建数组

```java
// 方式一
int[] arr1 = new int[3];
for(int i=0;i<arr1.length;i++)
    arr1[i] = i;
// 方式二
int[] arr2 = new int[]{0,1,2};
// 方式三
int[] arr3 = {0,1,2};

for(int arr:arr2)
    System.out.println(arr);
```

### 数组属性和方法

数组只有唯一一个属性，那就是 length，那么这个属性在哪个类中呢？

我们使用反射来看看：

```java
// 返回所有字段
Field[] declaredFields = arr3.getClass().getDeclaredFields();
// 返回所有方法
Method[] declaredMethods = arr3.getClass().getDeclaredMethods();
System.out.println(declaredFields.length +":"+ declaredMethods.length);
```

结果竟然是：0 : 0，也就是没有字段和方法，那 length 是什么呢？是哪来的呢？

关于数组我们可以进行如下操作：

```java
int[] arr3 = {0,1,2};//创建数组
int[] arr4 = arr3;	//复制数组
arr4[0] = 10;		//替换值
int value = arr4[0];//获取值
System.out.println(value);
```

这些操作很容易理解，可是是怎么实现的呢？

在类 java.lang.reflect.Array 中有对应的实现方法：

```java
Object arr5 = Array.newInstance(int.class, 3);	//创建数组
int length = Array.getLength(arr5);				//获取长度
Array.set(arr5,0,10);							//设置值
Array.setInt(arr5,0,5);							//设置值(已知类型)
Object value = Array.get(arr5, 0);				//获取值
int intValue = Array.getInt(arr5, 0);			//获取值(已知类型)
```

### Arrays操作数组

```java
int[] arr = {0, 1, 3, 2, 3};
// 排序
Arrays.sort(arr);// [0, 1, 2, 3, 3]
// 二分查找
int index = Arrays.binarySearch(arr,1);// 数组需要排序
// 复制数组
int[] copyArr = Arrays.copyOf(arr, arr.length);
int[] rangeArr = Arrays.copyOfRange(arr,0,2);//范围复制 [0, 1]
// 数组相等
int[] arr2 = {0, 1, 2, 3, 3};
boolean equal = Arrays.equals(arr,arr2);// true (以相同顺序包含相同的元素,null也相等)
// 给数组分配值
Arrays.fill(arr2,4);// [4, 4, 4, 4, 4]
Arrays.fill(arr2,0,2,5);//范围分配 [5, 5, 4, 4, 4]
// 基于数组内容返回哈希码
int hashcode = Arrays.hashCode(arr); // 28660960
// 返回数组内容的字符串表示
String arrString = Arrays.toString(arr);// [0, 1, 2, 3, 3]
```

#### Arrays.toString(arr) 源码

```java
StringBuilder b = new StringBuilder();
b.append('[');
for (int i = 0; ; i++) {
    b.append(arr[i]);
    if (i == arr.length - 1)
        return b.append(']').toString();
    b.append(", ");
}
```

对数组的复制操作其实是调用 System.arraycopy 这个静态方法实现的，编译器也推荐用此方法进行数组复制。

```java
public static int[] copyOf(int[] original, int newLength) {
    int[] copy = new int[newLength];
    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
    return copy;
}
```

## ArrayList源码

数组有诸多优点，当然也有缺点，官方定义了 ArrayList<E>、Vector<E> 等类来增强数组的使用。这里看一下 ArrayList 源码。毕竟有诸多优点：高效的实现、良好的设计、优秀的数据结构和算法......

### 属性字段

```java
private static final long serialVersionUID = 8683452581122892189L;
// 初始化数组容量
private static final int DEFAULT_CAPACITY = 10;
// 空数组
private static final Object[] EMPTY_ELEMENTDATA = {};
// 默认容量的空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
// 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度
// 当添加第一个元素时，拓展成 DEFAULT_CAPACITY
transient Object[] elementData;//非私有，以简化嵌套类访问
// 包含元素的个数
private int size;
```

- transient

### 构造方法

```java
1，指定容量
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        this.elementData = new Object[initialCapacity];// 创建缓冲区数组
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {								// 非法容量
        throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
    }
}
2，默认容量
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
3，包含指定集合元素
/**
 * 将集合传给 elementData
 * 将 elementData 转换为 Object 类型
 */
public ArrayList(Collection<? extends E> c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
```

### 其他方法

#### trimToSize

```java
/**
 * 修剪 ArrayList 实例的容量为 size 大小。可以使用此操作来最小化 ArrayList 实例的存储。
 */ 
public void trimToSize() {
    modCount++;
    if (size < elementData.length) {
        elementData = (size == 0)
            ? EMPTY_ELEMENTDATA
            : Arrays.copyOf(elementData, size);
    }
}
```



### 时间复杂度

O 简单来说是算法的运行时间和输入数据之间的关系，具体成为渐进时间复杂度，即 n 趋于无穷的时候

```java
public static int sum(int[] nums){
    int sum = 0;
    for(int num: nums) sum += num;
    return sum;
}
```

此算法就是 O(n)

n就是数组中元素个数

此算法运行时间和n成线性关系，即 T=cn+m，我们忽略这些常数，得到 O(n)

T = 2 * n * n + m 		O(n^2)

T = 2 * n * n + 2 * n +2	O(n^2)

