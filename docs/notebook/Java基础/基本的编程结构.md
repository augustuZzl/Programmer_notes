### 二进制

二进制数据据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二。

#### 基本运算

- 加法：1+1=10	0+1=1	1+0=1	0+0=0
- 乘法：1×1=1         1×0=0      0×1=0    0×0=0

#### 进制转换

- 十进制 ==> 二进制：8（10）

  8 / 2 = 4 余 0

  4 / 2 = 2 余 0

  2 / 2 = 1 余 0

  1 / 2 = 0 余 1

  则 8 的二进制就是 1 0 0 0

  其余方法转二进制可以先转十进制，再转二进制

- 二进制 ==> 十进制：1000（2）

  1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 = 8

  其余进制转十进制与此方法相同

- 快速进制转换

  现在有一个二进制数 1001 0110 

  - 转八进制：每三位为八进制数的一位，即 10  010  110 ==> 2 2 6
  - 转十六进制：每四位为十六进制数的一位，即 1001  0110 ==> 9 6

#### 原码、反码、补码

机器数就是8位二进制，第一位代表的符号位。

机器数带符号：正数最高位为0，负数最高位为1

​	原码：符号位加上真值的绝对值

​	反码：正数的反码是其本身，

　　　　　负数的反码就是在其原码的基础上，符号位不变，其余各位取反

​	补码：正数的补码就是其本身，

　　　　　负数的补码就是在原码的基础上，符号位不变，其余各位取反，最后 +1。即，在反码 + 1

　　　　   补码转原码，符号位不变，其余各位取反加一。

#### 位运算

- **<<** 左移：就是在二进制的右侧空位补 0

  例如一个数 10，其二进制是：1010，我们左移两位，那么就是 101000，十进制就是 40。

  使用 Java 来操作一下。

```java
int leftShift = 10;
System.out.println("十进制:"+leftShift+", 二进制:"+Integer.toBinaryString(leftShift));
int newLeftShift = leftShift << 2;
System.out.println("左移2位后十进制:" + newLeftShift + ", 左移2位后二进制" + Integer.toBinaryString(newLeftShift));
```

```txt
十进制:10, 二进制:1010
左移2位后十进制:40, 左移2位后二进制101000
```

​	没错：正整数 x 左移 n 位后的十进制结果，x = x * 2^n。

​	看看 -10 的结果：

```txt
十进制:-10, 二进制:11111111111111111111111111110110
左移2位后十进制:-40, 左移2位后二进制11111111111111111111111111011000
```

​	这些高位为什么都变为 1 了呢？这是因为 Java 负数是以补码形式存储的，从上面我们知道，补码等于反码加一。10 的二进制是 1010，反码就是 0101，在加上一就是补码 0110。可我们知道 int 是 32 位，原先高位都是 0，反码自然就是 1 了。

- **>> ** 右移：就是在左侧空位补符号位，正数用 0 补，负数用 1 补。

  例如一个数 10，其二进制是：1010，我们右移两位，那么就是 0010，十进制就是 2。

  ```java
  int rightShift = 10;
  System.out.println("十进制:" + rightShift + ", 二进制:" + Integer.toBinaryString(rightShift));
  int newRightShift = rightShift >> 2;
  System.out.println("右移2位后十进制:" + newRightShift + ", 右移2位后二进制" + Integer.toBinaryString(newRightShift));
  ```

  ```tex
  十进制:10, 二进制:1010
  右移2位后十进制:2, 右移2位后二进制10
  ```

  一直右移最后的结果就会是 0

  我们继续看看 -10 的结果：

  ```txt
  十进制:-10, 二进制:11111111111111111111111111110110
  右移2位后十进制:-3, 右移2位后二进制11111111111111111111111111111101
  ```

  一直右移最后的结果就会是 -1

- **>>>** 无符号右移：不管正数还是负数，高位都用0补齐

  显然，正数的无符号右移与有符号右移结果相同。

  在来看负数：

  ```txt
  十进制:-10, 二进制:11111111111111111111111111110110
  右移2位后十进制:1073741821, 右移2位后二进制111111111111111111111111111101
  ```

  可以看到高 2 为的 0 省略了。

  没有无符号左移啊，这很容易理解。

- **^**  取反：就是每一位都取反，即0变1，1变0.	

- **~**：比特位反转	

- **|** 按位或：参加运算的两个对象只要有一个为1，其值为1：1010 | 1100 = 1110

- **&** 按位与：两位同时为“1”，结果才为“1”，否则为0：1001 & 0101 = 1101


### 无符号类型

byte 一个字节，8 位；int 四个字节，32 位。所以，对于一个int型，我们需要一个长度为 4 的 byte 型数组来对其进行存储。

| int  | 31位——24位 | 23位——16位 | 15位——8位 | 7位——0位 |
| ---- | ---------- | ---------- | --------- | -------- |
| byte |            |            |           | 7位——0位 |

因此可以明显的看到将 byte 强制转为 int ,最高的三个字节会被砍掉，只留下最低的 8 位赋值给 byte 型。

我们先用 byte 数组来模拟一下 int 的组成：将 32 位 int 转换为四个 8 位 byte 数组：

```java
public static byte[] intToByte4(int sum) {
    byte[] arr = new byte[4];
    arr[3] = (byte) (sum >> 24);
    arr[2] = (byte) (sum >> 16);
    arr[1] = (byte) (sum >> 8);
    arr[0] = (byte) sum;
    return arr;
}
```

反过来，看一下 byte 型数组转换成 int 型：

```java
public static int byte4ToInt(byte[] bytes) {
    int int0 = bytes[0] & 0xff;
    int int1 = (bytes[1] & 0xff) << 8;
    int int2 = (bytes[2] & 0xff) << 16;
    int int3 = (bytes[3] & 0xff) << 24;
    return int0 | int1 | int2 | int3;
}
```

上面这个函数基本能够看懂什么意思，但我们看到 bytes[i] 有` bytes[i] & 0xff` 这个操作，0x 代表 16 进制，f 就是 1111，所以 0xff 就是 1111 1111。为什么会有这个操作呢？

我们知道 byte 在进行操作的时候会自动补全到 32 位，即一个 int 类型。

我们假设这个数组是：

![1](https://ws1.sinaimg.cn/large/006DgVHEly1g0l7lsa0z6j30f20553ye.jpg)

前面我们知道，负数的高位用 1 补全了，如果我们不对其进行 &0xff 操作的话：

![2](https://ws1.sinaimg.cn/large/006DgVHEly1g0l7yienpej30cm03h0sj.jpg)

我们要将红框组合成 32 位的 int ，在进行 | 操作的时候，高位上的 1 就会导致结果出错，我们得到的是错误结果：`11111111111111111111111111111111`，而不是正确结果：`000000010000000011111111011111111`。所以我们要将前面的符号位去除，即使用：&0xff，就很简单理解了，在此就不演示了。

学过 C# 的应该知道，C# 基本数据类型分为很多种，其中就包括无符号类型。在 Java 中，不存在 Unsigned 无符号数据类型。但是如果你使用的值不可能是负值，那么你可以将数值翻译成无符号类型。

例如：做网络通讯时，处理的数据往往都是无符号的 byte ，值的范围是0-255，当我们接收到一个值为 200 的 byte 时，在 Java 中就显示 -56，这就是因为我们 Java 中没有无符号这一说法，因此就会不正确，所以如何得到正确的 200 呢？我们仅需一条很简单的语句便可搞定：

```java
int unsignedValue = signedByte >= 0 ? signedByte : signedByte + 256;
```

当然官方也提供了 API(1.8)：`Byte.toUnsignedInt(byte b)`:

```java
public static int toUnsignedInt(byte x) {
    return ((int) x) & 0xff;
}
```

这里就用到了我们上面提到的 &0xff 了。Integer 和 Long 也有无符号除法和余数方法。

### 斜杠和反斜杠

一直分不清楚斜杠和反斜杠之间的区别，在此好好研究一下。

> 除了在程序中，其他地方几乎不用 ' \ '。
>
> ' / ' 分隔符，' \ ' 转义字符
>
> 形象点：' / ' 是一个人向前倾倒，' \ ' 是一个人向后倾倒

在绝大多数地方，用的都是 ' / '（slash），包括 Mac / Linux，也包括 URL 。你唯一需要记住的是，Microsoft 这个怪鸡在自己的操作系统里面偏要用 ' \ '（backslash），使得自己与众不同。

我们可以打开 windows 的 cmd 窗口，可以看到：`C:\Users\Augustu>`

目前 windows 系统上的文件浏览器都是用反斜杠 ' \ ' 作为路径分隔符。随着发展，DOS 系统已经被淘汰了，命令提示符也用得很少，斜杠和反斜杠在大多数情况下可以互换，没有影响。

我们总结一下：

>浏览器地址栏网址使用 正斜杠 ' / '
>
>windows 文件浏览器上使用 反斜杠 ' \ '
>
>出现在 html url() 属性中的路径，使用 正斜杠 ' / '
>
>出现在普通字符串的路径，如果代表的是 windows 文件路径，则使用 正斜杠 和反斜杠是一样的；如果代表的是网络文件路径，则必须使用正斜杠 ' / '

.