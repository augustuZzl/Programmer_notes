#### 思路

从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的大元素上浮到右侧。
在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。

#### 代码实现

```java
public class Bubble<T extends Comparable<T>> extends Sort<T>{

    // 排序
	@Override
	public void sort(T[] nums) {
		int N = nums.length;
		boolean isSwap = false;
		for(int i = N - 1; i > 0 && isSwap; i--){
			isSwap = false;
			for(int j = 0; j < i; j++){
				if(less(nums[j+1], nums[j])){
					swap(nums, j, j+1);
					isSwap = true;
				}
			}
		}
	}

}
```

- 整个过程需要两个循环，一个循环表示冒泡的次数，另一个循环表示从头开始冒泡
- 因为最大元素经过一次冒泡后数组最后一个位置就确定了，所以第一层从最后一个元素开始遍历到第二个元素就可以了，第一个元素就不需要动了
- 第二层循环 j，从 第一个位置开始遍历到 i 前，因为 i 之后的元素已经排好序了
- isSwap 来检查是否发生过交换，如果没有交换过则表示排序已完成，没必要进行到底了，退出即可了。

#### 复杂度分析：

此算法与选择排序差不多。

#### 总结



