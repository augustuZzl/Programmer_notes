#### 堆

堆中某个节点的值总是大于等于或小于其子节点的值，并且堆是一颗完全二叉树。

堆分为小顶堆、大顶堆。我们可以用来解决最大或最小的 k 个数等问题，并具有高效率。

例如有一万个数，求出其中 100 个最大的值。我们就可以构建节点为 100 的小顶堆，每取出一个数，与堆顶元素比较，小于则丢弃，大于，则该数变为堆顶并下沉。这样便利完一万个数，最大的100个数便构成了这个小顶堆。

**下面我们所有操作针对大顶堆。**

#### 堆得表示

因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。

位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。

```java
public class Heap<T extends Comparable<T>> {
	
	private T[] heap;
	private int N = 0;

	// 构建堆,即初始化数组
	public Heap(int maxN){
		this.heap = (T[]) new Comparable[maxN + 1];
	}
	
	public boolean isEmpty(){
		return N == 0;
	}
	
	public int size(){
		return N;
	}
	
	// 比较和交换用来自动上浮和下沉
	private boolean less(int i, int j){
		return heap[i].compareTo(heap[j]) < 0;
	}
	private void swap(int i, int j){
		T temp = heap[i];
		heap[i] = heap[j];
		heap[j] = temp;
	}

}
```

#### 上浮和下沉

在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。

```java
private void swim(int k){
    // 当该节点不是根节点并且比父节点大
    while(k > 1 && less(k / 2, k)){
        swap(k / 2, k);
        k = k / 2;
    }
}
```

类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。

```java
private void sink(int k){
    // 当有孩子
    while(k * 2 <= N){
        // j 代表要交换的孩子
        int j = 2; // 左孩子
        if(j < N && less(j, j + 1)) // 如果有右孩子并且右孩子大
            j++;
        if(!less(k, j)) // 如果不必孩子小，结束
            break;
        swap(k, j);
        k = j;
    }
}
```

#### 插入元素

将新元素放在数组末尾，进行上浮操作

```java
public void add(T t){
    heap[++N] = t;
    swim(N);
}
```

#### 删除堆顶元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。

```java
public T delTop(){
    T temp = heap[1];
    heap[1] = heap[N--];
    heap[N + 1] = null; // 将此处置空
    sink(1);
    return temp;
}
```

#### 堆排序

把最大元素和当前堆中数组的最后一个元素交换位置，但是不删除它，那么重复进行此操作，最后就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。

##### 构建堆

我们在构建堆的时候，是上浮操作。一个更高效的做法就是从最后一个叶节点的父节点开始往前遍历，进行下沉操作，该节点后边的都是叶节点，不需要进行下沉操作。因此只需要遍历一半元素即可了。

##### 交换堆顶与最后一个元素

交换之后需要进行下沉操作维持堆的有序状态。

```java
public class HeapSort<T extends Comparable<T>> extends Sort<T> {
    /**
     * 数组第 0 个位置不能有元素,传入的数组第一个元素置空就行了
     */
    @Override
    public void sort(T[] nums) {
        int N = nums.length - 1;
        for (int k = N / 2; k >= 1; k--)
            sink(nums, k, N);

        while (N > 1) {
            swap(nums, 1, N--);
            sink(nums, 1, N);
        }
    }

    private void sink(T[] nums, int k, int N) {
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(nums, j, j + 1))
                j++;
            if (!less(nums, k, j))
                break;
            swap(nums, k, j);
            k = j;
        }
    }

    private boolean less(T[] nums, int i, int j) {
        return nums[i].compareTo(nums[j]) < 0;
    }
}
```

