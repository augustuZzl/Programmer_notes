#### 思路

每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。
插入排序每次只能交换相邻元素，所以将当前元素依次与左侧已排好序的元素进行比较，如果小，则交换继续与下一个比较；如果大，则停止交换。进行下一个元素。

#### 代码实现

```java
public class Insertion<T extends Comparable<T>> extends Sort<T>{

	@Override
	public void sort(T[] nums) {
		int N = nums.length;
		for(int i = 1; i < N; i++){
			for(int j = i; j > 0 && less(nums[j], nums[j-1]); j--){
				swap(nums, j, j-1);
			}
		}
	}
    
}
```

- 整个过程需要两个循环，一个循环表示要插入的元素，另一个循环表示将要插入的元素与左边排好序的进行比较和交换

#### 复杂度分析：

对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)。令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。

插入排序的复杂度取决于数组的初始顺序，如果数组已经部分有序了，逆序较少，那么插入排序会很快。
平均情况下插入排序需要 ~N^2/4  比较以及 ~N^2/4 次交换； 坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，坏的情况是数组是倒序的； 好的情况下需要 N-1 次比较和 0 次交换，好的情况就是数组已经有序了。

#### 总结



