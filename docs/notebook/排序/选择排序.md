#### 思路

选择出数组中的小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出小的元素，将它与数组的 第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

#### 代码实现

```java
public class Selection<T extends Comparable<T>> extends Sort<T> {

    // 排序
	@Override
	public void sort(T[] nums) {
		int N = nums.length;
		for(int i = 0; i < N - 1; i++){
			int min = i;
			for(int j = i + 1; j < N; j++){
				if(less(nums[j], nums[min])){
					min = j;
				}
			}
			swap(nums, i, min);
		}
	}
	
    // 测试
	public static void main(String[] args) {
		Integer[] a = {3,2,5,8,1,6};
		Selection<Integer> s = new Selection<>();
		s.sort(a);
		System.out.println(Arrays.toString(a));
	}

}
```

- 整个过程需要两个循环，一个循环表示当前要替换的位置，另一个循环从剩余元素中寻找最小元素
- 第一层循环 i，要从第一个位置遍历到倒数第二个位置
- 第二层循环 j，从 i 后面开始遍历到最后一个位置，因为 i 之前的元素已经排好序了
- 令 min 代表最小元素的位置，当 j 遍历完，交换 min 位置和 i 位置的元素
- 测试的数组 a 要 Integer，不能是 int 
- `java.util.Arrays.toString()`：将数组表示为字符串形式

#### 复杂度分析

1. 第二层循环进行的是比较操作：

- 当 i = 0：j 走 n - 1 次

- 当 i = 1：j 走 n - 2 次

- ......

- 当 i = n - 2：j 走 1 次

  总共需要：

$$
1 + 2 + 3 + \underbrace{\cdots}_{\rm cdots} + (n - 2) + (n - 1) = (1 + (n - 1)) (n - 1) / 2 = n(n - 1)  / 2 ≈n^2 / 2
$$

2. 第一层就是交换通过第二层获取的最小元素也就是 n 次了。

#### 总结

我们可以看到他的运行时间与输入元素无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。

